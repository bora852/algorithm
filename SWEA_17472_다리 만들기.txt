import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class Main {
	//2 ≤ 섬의 개수 ≤ 6
	//1 ≤ N, M ≤ 10
	
	static int N, M, ans, islandCnt;
	static int[][] map, label, dist;
	static boolean[][] visit;
	static boolean[] connect; 			//연결관계 체크를 위한 배열??
	static boolean[] connectIsland;		//섬끼리 연결되어 있는지, bfs탐색시, 방문체크를 위한 배열
	static boolean[] select;			//조합 추출에서 중복을 막기 위한 배열
	
	static ArrayList<Point> list; 		//입력시 모든 섬의 좌표를 저장
	static Point[][] area_pos; 	//각 섬에 존재하는 땅의 좌표 저장
	static ArrayList<ArrayList<Point>> bridgeList;
	
	static int[] dr = {-1, 1, 0, 0};
	static int[] dc = {0, 0, -1, 1};
	
	static final int INF = 999;
	
	public static void main(String[] args) {
//		Scanner sc = new Scanner(System.in);
		Scanner sc = new Scanner(src);
		
		N = sc.nextInt();
		M = sc.nextInt();
		map = new int[N][M];
		dist = new int[N][M];
		label = new int[N][M];
		visit = new boolean[N][M];
		
		list = new ArrayList<>();
		area_pos = new Point[7][];
		bridgeList = new ArrayList<ArrayList<Point>>();
		
		for(int i = 0; i < N; i++) {
			for(int j = 0; j < M; j++) {
				dist[i][j] = INF;
				map[i][j] = sc.nextInt();
				if(map[i][j] == 1) list.add(new Point(i, j)); 
			}
		}
		
		makeLabel(); 	//섬의 번호를 붙이는 메서드
		findDistance(); //섬끼리 최단거리 구하기
	}
	
	static void findDistance() {
		/*
		 * 섬들간의 최단거리를 구하는 메서드
		 * 시작점과 끝점을 정하고, DFS 탐색
		 */
		for(int i = 1; i < islandCnt; i++) {
			for(int j = i + 1; j < islandCnt; j++) {
				makeBridge(i, j);
				if(dist[i][j] == INF)continue;
			}
		}
	}
	
	static void makeBridge(int srt, int end) {
		/*
		 * 시작 섬에 존재하는 모든 땅들에서 도착섬까지 탐색해본다.
		 */
		for(int i = 0; i < area_pos[srt].length; i++) {
			int r = area_pos[srt][i].r;
			int c = area_pos[srt][i].c;
			
			for(int k = 0; k < 4; k++) {
				int nr = r + dr[k];
				int nc = c + dc[k];
				if(isRange(nr, nc) && map[nr][nc] == 0) dfs(r, c, k, 0, srt, end);
			}
		}
	}
	
	static void dfs(int r, int c, int dir, int bsize, int srt, int end) {
		int nr = r + dr[dir];
		int nc = c + dc[dir];
		
		if(!isRange(nr, nc)) return;
		
		if(map[nr][nc] == 0) dfs(nr, nc, dir, bsize + 1, srt, end);
		else if(map[nr][nc] == 1) {
			if(label[nr][nc] == end) {
				if(bsize > 1) {
					if(dist[srt][end] > bsize) { //최소다리길이로 갱신
						dist[srt][end] = bsize;
						dist[end][srt] = bsize;
					}
					return;
				}
			}else return;
		}
	}
	
	static void makeLabel() {
		/*	섬의 번호를 붙이는 메서드
			섬의 좌표를 저장해놓은 list를 탐색하면서
			아직 방문하지 않은 좌표들을 BFS 탐색
		*/
		int labelNum = 1;
		for(int i = 0; i < list.size(); i++) {
			Point p = list.get(i);
			if(!visit[p.r][p.c]) bfs(p.r, p.c, labelNum);
		}
		islandCnt = labelNum;
	}
	
	static void bfs(int r, int c, int num) {
		Queue<Point> q = new LinkedList<>();
		q.add(new Point(r, c));
		visit[r][c] = true;
		label[r][c] = num;
		int cnt = 0;
		area_pos[num][cnt++] = new Point(r, c);
		while(!q.isEmpty()) {
			Point p = q.poll();
			for(int i = 0; i < 4; i++) {
				int nr = p.r + dr[i];
				int nc = p.c + dc[i];
				
				if(isRange(nr, nc) && !visit[nr][nc] && map[nr][nc] == 1) {
					visit[nr][nc] = true;
					label[nr][nc] = num;
					q.add(new Point(nr, nc));
					area_pos[num][cnt++] = new Point(nr, nc);
				}
				
			}
		}
	}
	
	static boolean isRange(int r, int c) {
		return 0 <= r && r < N && 0 <= c && c < M;
	}
	
	static class Point{
		int r, c;
		Point(int r, int c){
			this.r = r;
			this.c = c;
		}
	}
	static String src = "7 8\r\n" + 
			"0 0 0 0 0 0 1 1\r\n" + 
			"1 1 0 0 0 0 1 1\r\n" + 
			"1 1 0 0 0 0 0 0\r\n" + 
			"1 1 0 0 0 1 1 0\r\n" + 
			"0 0 0 0 0 1 1 0\r\n" + 
			"0 0 0 0 0 0 0 0\r\n" + 
			"1 1 1 1 1 1 1 1";
}